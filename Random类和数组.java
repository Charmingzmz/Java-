1.Random类:用于产生一个随机数的类;
	使用步骤:
		1.创建随机数对象;
			Random r = new Random();
		2.产生随机数,并接收!
			int numr = r.nextInt(随机数的范围);//范围区间:包左不包右
				例如: r.nextInt(10);  //随机数范围区间:[0,9]<==>[0,10);
			问题:若我要随机生成一个负数:==>  -r.nxetInt(区间范围);

2.数组:数组是我们学习的第一个引用数据类型;
	数组概念:数组是用来存储同一种数据类型的多个元素的容器;
	定义格式:
		数据类型[] 数组名  //举例: int[] arr;
		
		//1.数组的长度是不可以变化的;
		//2.数据的类型是一样的;
		//3.数组中的元素是有索引的;
			--->每个元素的标记 索引是从0开始一直到数组的长度-1;
	动态初始化和静态初始化的区别:
		动态初始化是由我们给出数组元素的个数数组的长度,系统默认给与数组的初始值;
		静态初始化是由我们给出数组元素的具体值,由系统自动判断数组的长度和元素个数;
		
	动态初始化:
		数据类型[] 数组名 = new 数据类型[元素个数];
		举例:
			int[] arr = new int[3];
				//定义了一个int类型的数组,数组的长度是3,元素个数是3,最大索引是2;
				
	数组的元素访问:
		访问的格式:
			数组的数据类型 变量名 = 数组名[索引];
			//举例: int[] arr = new int[3];   ====> int num = arr[索引];
		索引:
			索引是数组中元素的编号;它的起始索引是0,结束索引是元素个数-1或者数组的长度-1;
	数组的静态初始化:
		格式: 数据类型[] 数组名 ={元素1,元素2,元素3....};
		
	//什么时候使用静态初始化什么时候使用动态初始化?
		1.当我们知道数组元素具体的个数和值的时候我们使用静态初始化;
		2.当我们只知道数组的长度那么我们使用动态初始化;
		
可能出现的异常:
	1.ArrayIndexOutOfBoundsException:索引越界异常;
		出现的原因:访问了不存在的索引元素;
		解决方案:找到错误代码,访问正确的元素;
	2.NullPointerException:空指针异常;
		出现的原因:访问了不存在的地址中的元素;
		解决方案:
			1.debug模式找到出错位置;//因为debug模式可以看到每一个变量的值;
			2.找到出错代码,不去访问不存在的地址中的元素;

二维数组:二维数组是用来存储一维数组的容器--->它也是一个数组  //二维数组可以看作一条烟
	//大部分的一条烟中有10包烟
	二维数组的定义格式:
		数据类型[][] 数组名;
	二维数组的初始化:
		动态初始化:	
			数据类型[][] 数组名 = new 数据类型[m][n];
				m:代表的是二维数组中一维数组的个数;
				n:代表的是二维数组中的一维数组中的元素个数;
			//举例:
				黄鹤楼[][] 蓝楼 = new 黄鹤楼[10][20];
				int[][] arr = new int[m][n];
				
		静态初始化:
			数据类型[][] 数据名 = {{元素1,元素2,元素3..},{元素1,元素2,元素3..},{元素1,元素2,元素3..}..};
		
		当我们直接输出二维数组名:得到的是二维数组的地址值;
		当我们输出二维数组[m]:得到的是二维数组中一维数组的地址值;
		那么我们要拿到二维数组中的元素: 输出==>二维数组名[m][n];
	
	二维数组的遍历://for循环的嵌套
		for(int x = 0;x < arr.length;x++){
			for(int y = 0;y<arr[x].length;y++){
				System.out.println(arr[x][y]);
			}
		}
	
	
	
	
	
	
	
	
	
	
		
				